<!doctype html><html><head>
<meta charset="utf-8"/><title>NOFX - Settings</title>
<link rel="stylesheet" href="/ui/static/style.css"/>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.16.0/cdn/themes/dark.css"/>
<script type="module" src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.16.0/cdn/shoelace.js"></script>
</head><body>
<div class="header"><div class="inner">
  <div class="brand"><a href="/ui/runs">NOFX</a></div>
  <div class="nav">
    <a href="/ui/runs">Runs</a>
    <a href="/ui/models">Models</a>
    <a href="/ui/settings">Settings</a>
  </div>
</div></div>
<div class="container">
<div class="section-title"><h1 style="margin:12px 0">Settings</h1><span class="tip" data-tip="Configure approvals, gates, and AI routing.">?</span></div>

<sl-card><div class="bd">
  <div slot="header">Approvals</div>
  <label>DB Writes require approval:
    <select id="dbWrites">
      <option value="none">None</option>
      <option value="dangerous">Dangerous only (update/delete)</option>
      <option value="all">All writes</option>
    </select>
  </label>
  <label>
    <input type="checkbox" id="allowWaive"/> Allow Waive (dev only)
  </label>
</div></sl-card>

<!-- Providers are managed on the Models page -->

<sl-card style="margin-top:16px"><div class="bd">
  <div slot="header">Checks (Gates)</div>
  <label><input type="checkbox" id="gateTypecheck"/> Typecheck</label>
  <label><input type="checkbox" id="gateLint"/> Lint</label>
  <label><input type="checkbox" id="gateUnit"/> Unit</label>
  <label>Coverage Threshold: <input type="number" id="coverage" min="0" max="100" step="1"/> %</label>
</div></sl-card>

<sl-card style="margin-top:16px"><div class="bd">
  <div slot="header">Data Writes (Allow-list)</div>
  <p>Allowed operations by table. Add rows as needed.</p>
  <table id="rulesTable">
    <tr><th>Table</th><th>Insert</th><th>Update</th><th>Delete</th><th></th></tr>
  </table>
  <button onclick="addRuleRow()">Add Rule</button>
</div></sl-card>

<sl-card style="margin-top:16px"><div class="bd">
  <div slot="header">AI Routing</div>
  <p>Select model order for each task. Manage models on the <a href="/ui/models">Models</a> page.</n>
  <div>
    <h3>Docs</h3>
    <sl-select id="docsSelect" clearable hoist></sl-select>
    <button onclick="addToOrder('docs')">Add</button>
    <ul id="docsOrder"></ul>
  </div>
  <div>
    <h3>Reasoning</h3>
    <sl-select id="reasoningSelect" clearable hoist></sl-select>
    <button onclick="addToOrder('reasoning')">Add</button>
    <ul id="reasoningOrder"></ul>
  </div>
  <div>
    <h3>Codegen</h3>
    <sl-select id="codegenSelect" clearable hoist></sl-select>
    <button onclick="addToOrder('codegen')">Add</button>
    <ul id="codegenOrder"></ul>
  </div>
</div></sl-card>

<div style="margin:12px 0">
  <button class="btn primary" onclick="save()">Save</button>
  <span id="status" class="muted" style="margin-left:8px"></span>
  <a style="margin-left:12px" href="/ui/models">Manage Models</a>
</div>

<% /* Dev-only restart (visible always; backend checks NODE_ENV/role) */ %>
<sl-card style="margin-top:16px"><div class="bd">
  <div slot="header">Development</div>
  <button class="btn" onclick="restartBackend()" title="Writes a restart flag; dev server exits and restarts.">Restart Backend</button>
  <small style="color:#666">Requires DEV_RESTART_WATCH=1 in .env and admin login. No effect in production.</small>
  <span id="devStatus"></span>
  <p>Tip: This restarts both API and Worker processes started by npm run dev.</p>
</div></sl-card>

<script>
async function load(){
  const rsp = await fetch('/settings');
  const { settings, db_write_rules, models } = await rsp.json();
  document.getElementById('dbWrites').value = settings.approvals.dbWrites;
  document.getElementById('allowWaive').checked = !!settings.approvals.allowWaive;
  document.getElementById('gateTypecheck').checked = !!settings.gates.typecheck;
  document.getElementById('gateLint').checked = !!settings.gates.lint;
  document.getElementById('gateUnit').checked = !!settings.gates.unit;
  document.getElementById('coverage').value = Math.round((settings.gates.coverageThreshold||0.9)*100);
  const table = document.getElementById('rulesTable');
  // clear existing rows except header
  while (table.rows.length > 1) table.deleteRow(1);
  for (const r of db_write_rules) {
    addRuleRow(r.table_name, r.allowed_ops||[]);
  }
  // Load models for dropdowns with friendly labels (provided in same response)
  let activeModels = (models||[]).filter(m => m.active !== false);
  // Fallback options if no DB models exist yet
  if (!activeModels.length) {
    activeModels = [
      { provider: 'openai', name: (window.OPENAI_MODEL || 'gpt-5'), display_name: 'OpenAI (gpt-5)' },
      { provider: 'anthropic', name: (window.ANTHROPIC_MODEL || 'claude-4-sonnet'), display_name: 'Anthropic (Claude 4 Sonnet)' },
      { provider: 'gemini', name: (window.GEMINI_MODEL || 'gemini-2.5-pro'), display_name: 'Gemini (2.5 Pro)' }
    ];
  }
  window._labelByName = {};
  const modelOptions = activeModels.map(m => ({ value: m.name, label: `${m.provider}: ${m.display_name || m.name}` }));
  modelOptions.forEach(m => _labelByName[m.value] = m.label);
  for (const selId of ['docsSelect','reasoningSelect','codegenSelect']){
    const sel = document.getElementById(selId);
    sel.innerHTML = '';
    modelOptions.forEach(m => {
      const opt = document.createElement('sl-option');
      // Set both property and attribute to satisfy web component upgrade timing
      opt.value = m.value; opt.setAttribute('value', m.value);
      opt.textContent = m.label;
      sel.appendChild(opt);
    });
  }
  state.docs = (settings.llm && settings.llm.modelOrder && settings.llm.modelOrder.docs) || [];
  state.reasoning = (settings.llm && settings.llm.modelOrder && settings.llm.modelOrder.reasoning) || [];
  state.codegen = (settings.llm && settings.llm.modelOrder && settings.llm.modelOrder.codegen) || [];
  // If model order is empty and we have fallback options, prefill one entry each for quick start
  if (!state.docs.length && modelOptions.length) state.docs = [modelOptions[0].value];
  if (!state.reasoning.length && modelOptions.length) state.reasoning = [modelOptions[0].value];
  if (!state.codegen.length && modelOptions.length) state.codegen = [modelOptions[0].value];
  renderOrder('docs'); renderOrder('reasoning'); renderOrder('codegen');

  // Providers UI removed; manage providers via Models page
}

function addRuleRow(tableName='', ops=[]){
  const t = document.getElementById('rulesTable');
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td><input value="${escapeHtml(tableName)}" placeholder="schema.table"/></td>
    <td><input type="checkbox" ${ops.includes('insert')?'checked':''}></td>
    <td><input type="checkbox" ${ops.includes('update')?'checked':''}></td>
    <td><input type="checkbox" ${ops.includes('delete')?'checked':''}></td>
    <td><button onclick="this.closest('tr').remove()">Remove</button></td>
  `;
  t.appendChild(tr);
}

function collectRules(){
  const t = document.getElementById('rulesTable');
  const out = [];
  for (let i=1;i<t.rows.length;i++){
    const cells = t.rows[i].cells;
    const table = cells[0].querySelector('input').value.trim();
    if (!table) continue;
    const allowed_ops = [];
    if (cells[1].querySelector('input').checked) allowed_ops.push('insert');
    if (cells[2].querySelector('input').checked) allowed_ops.push('update');
    if (cells[3].querySelector('input').checked) allowed_ops.push('delete');
    out.push({ table_name: table, allowed_ops });
  }
  return out;
}

async function save(){
  const body = {
    settings: {
      approvals: {
        dbWrites: document.getElementById('dbWrites').value,
        allowWaive: document.getElementById('allowWaive').checked
      },
      gates: {
        typecheck: document.getElementById('gateTypecheck').checked,
        lint: document.getElementById('gateLint').checked,
        unit: document.getElementById('gateUnit').checked,
        coverageThreshold: Math.max(0, Math.min(1, (Number(document.getElementById('coverage').value)||90)/100))
      },
      llm: { modelOrder: { docs: state.docs, reasoning: state.reasoning, codegen: state.codegen } }
    },
    db_write_rules: collectRules()
  };
  const rsp = await fetch('/settings', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
  const ok = rsp.ok;
  document.getElementById('status').textContent = ok ? 'Saved ✓' : 'Failed to save';
  if (ok) setTimeout(()=>document.getElementById('status').textContent='', 2000);
}

async function restartBackend(){
  const rsp = await fetch('/dev/restart', { method:'POST' });
  if (rsp.status === 401) { window.location.href = '/ui/login'; return; }
  document.getElementById('devStatus').textContent = rsp.ok ? 'Restarting…' : 'Failed';
}

function escapeHtml(s){
  return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;');
}
function parseProviders(s){
  const list = String(s||'').split(',').map(x=>x.trim().toLowerCase()).filter(Boolean);
  const uniq = Array.from(new Set(list));
  // Always append known built-ins if absent to keep fallback available
  for (const p of ['openai','anthropic','gemini']) if (!uniq.includes(p)) uniq.push(p);
  return uniq;
}
function numOrUndef(id){
  const v = Number(document.getElementById(id).value);
  return isFinite(v) && v > 0 ? v : undefined;
}

function addProviderRow(name='', kind='openai', baseUrl='', model='', priceIn='', priceOut=''){
  const t = document.getElementById('providersTable');
  const tr = document.createElement('tr');
  tr.innerHTML = `
    <td><input class="prov-name" value="${escapeHtml(name)}" placeholder="myllm"/></td>
    <td>
      <select class="prov-kind">
        ${['openai','anthropic','gemini','openai-compatible','http'].map(k=>`<option value="${k}" ${k===kind?'selected':''}>${k}</option>`).join('')}
      </select>
    </td>
    <td><input class="prov-base" value="${escapeHtml(baseUrl)}" placeholder="http://localhost:11434/v1/chat/completions"/></td>
    <td><input class="prov-model" value="${escapeHtml(model)}" placeholder="model-name"/></td>
    <td><input class="prov-price-in" type="number" step="0.01" min="0" value="${escapeHtml(priceIn)}"/></td>
    <td><input class="prov-price-out" type="number" step="0.01" min="0" value="${escapeHtml(priceOut)}"/></td>
    <td><button onclick="this.closest('tr').remove()">Remove</button></td>
  `;
  t.appendChild(tr);
}
function collectProviders(){
  const t = document.getElementById('providersTable');
  const out = {};
  for (let i=1;i<t.rows.length;i++){
    const row = t.rows[i];
    const name = row.querySelector('.prov-name').value.trim();
    if (!name) continue;
    out[name.toLowerCase()] = {
      kind: row.querySelector('.prov-kind').value,
      baseUrl: row.querySelector('.prov-base').value.trim() || undefined,
      model: row.querySelector('.prov-model').value.trim() || undefined,
    };
  }
  return out;
}
function collectProviderPricing(){
  const t = document.getElementById('providersTable');
  const out = {};
  for (let i=1;i<t.rows.length;i++){
    const row = t.rows[i];
    const name = row.querySelector('.prov-name').value.trim();
    if (!name) continue;
    const inP = Number(row.querySelector('.prov-price-in').value);
    const outP = Number(row.querySelector('.prov-price-out').value);
    if (isFinite(inP) || isFinite(outP)) {
      out[name.toLowerCase()] = { inputPer1M: isFinite(inP)?inP:undefined, outputPer1M: isFinite(outP)?outP:undefined };
    }
  }
  return out;
}

// Model-order UI state and helpers
const state = { docs: [], reasoning: [], codegen: [] };
function addToOrder(kind){
  const sel = document.getElementById(kind+'Select');
  if (!sel) return;
  let val = sel.value;
  if (!val) {
    const checked = sel.querySelector('sl-option[checked]') || sel.querySelector('sl-option[selected]');
    if (checked) val = checked.value;
  }
  if (!val) return;
  state[kind].push(val);
  try { sel.value = ''; } catch {}
  renderOrder(kind);
}
function renderOrder(kind){
  const ul = document.getElementById(kind+'Order');
  if (!ul) return;
  ul.innerHTML = '';
  state[kind].forEach((name, idx) => {
    const li = document.createElement('li');
    const label = (window._labelByName && window._labelByName[name]) || name;
    li.textContent = label + ' ';
    const up = document.createElement('button'); up.textContent = '↑'; up.onclick = ()=>{ if (idx>0){ const t=state[kind][idx-1]; state[kind][idx-1]=state[kind][idx]; state[kind][idx]=t; renderOrder(kind);} };
    const down = document.createElement('button'); down.textContent = '↓'; down.onclick = ()=>{ if (idx<state[kind].length-1){ const t=state[kind][idx+1]; state[kind][idx+1]=state[kind][idx]; state[kind][idx]=t; renderOrder(kind);} };
    const rm = document.createElement('button'); rm.textContent = '✕'; rm.onclick = ()=>{ state[kind].splice(idx,1); renderOrder(kind); };
    li.appendChild(up); li.appendChild(down); li.appendChild(rm);
    ul.appendChild(li);
  });
}

load();
</div>
</script>
</body></html>
