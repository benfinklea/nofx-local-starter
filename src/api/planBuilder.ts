import { getSettings } from "../lib/settings";
import { listAgents, listTemplates } from "../lib/registry";
import type { AgentSummary } from "../../packages/shared/src/agents";
import type { TemplateSummary } from "../../packages/shared/src/templates";

export function guessTopicFromPrompt(p: string) {
  if (!p) return 'NOFX';
  const m = p.split(/[.\n]/)[0] || p;
  const words = m.trim().split(/\s+/).slice(0, 8).join(' ');
  return words || 'NOFX';
}

export function guessMarkdownPath(p: string): string | undefined {
  if (!p) return undefined;

  // First, check for explicit .md file path in the prompt
  const m = p.match(/(?:^|\s)([\w\-/.]+\.md)\b/i);
  if (m) return m[1];

  // Check for "in docs" hint
  if (/\bin docs\b/i.test(p)) return 'docs/README.md';

  // Infer filename from content-type keywords
  const contentTypeMap: Record<string, string> = {
    'haiku': 'haiku.md',
    'poem': 'poem.md',
    'poetry': 'poem.md',
    'story': 'story.md',
    'letter': 'letter.md',
    'recipe': 'recipe.md',
    'tutorial': 'tutorial.md',
    'guide': 'guide.md',
    'instructions': 'instructions.md',
    'notes': 'notes.md',
    'summary': 'summary.md',
    'report': 'report.md',
    'analysis': 'analysis.md',
    'proposal': 'proposal.md',
    'spec': 'spec.md',
    'specification': 'specification.md'
  };

  const lowerPrompt = p.toLowerCase();
  for (const [keyword, filename] of Object.entries(contentTypeMap)) {
    // Match keyword as whole word (not part of another word)
    const regex = new RegExp(`\\b${keyword}\\b`, 'i');
    if (regex.test(lowerPrompt)) {
      return filename;
    }
  }

  return undefined;
}

type StepDef = { name: string; tool: string; inputs?: Record<string, unknown> };

export async function buildPlanFromPrompt(
  prompt: string,
  opts: { quality: boolean; openPr: boolean; filePath?: string; summarizeQuery?: string; summarizeTarget?: string; projectId?: string }
) {
  const { gates } = await getSettings();
  let agents: AgentSummary[] = [];
  let templates: TemplateSummary[] = [];
  try {
    const result = await listAgents({ status: 'active', limit: 10 });
    agents = result.agents;
  } catch {}
  try {
    const result = await listTemplates({ status: 'published', limit: 10 });
    templates = result.templates;
  } catch {}
  const steps: StepDef[] = [];
  if (opts.quality) {
    if (gates.typecheck) steps.push({ name: 'typecheck', tool: 'gate:typecheck' });
    if (gates.lint) steps.push({ name: 'lint', tool: 'gate:lint' });
    if (gates.unit) steps.push({ name: 'unit', tool: 'gate:unit' });
    const gx = gates as Record<string, unknown>;
    if (gx.sast === true) steps.push({ name: 'sast', tool: 'gate:sast' });
    if (gx.secrets === true) steps.push({ name: 'secret scan', tool: 'gate:secrets' });
    if (gx.audit === true) steps.push({ name: 'dependency audit', tool: 'gate:audit' });
  }
  const topic = guessTopicFromPrompt(prompt);
  const hinted = guessMarkdownPath(prompt);
  const targetPath = (opts.filePath && String(opts.filePath).trim()) || hinted || 'README.md';
  const filename = targetPath.split('/').pop() || 'README.md';
  const agentOptions = agents.map(a => ({ id: a.agentId, name: a.name }));
  const templateOptions = templates.map(t => ({ id: t.templateId, name: t.name }));

  const codegenStepName = 'write readme';
  steps.push({
    name: codegenStepName,
    tool: 'codegen',
    inputs: {
      topic,
      bullets: ['Control plane', 'Verification', 'Workers'],
      filename,
      agentOptions,
      templateOptions
    }
  });

  // If we have a project, add workspace:write step to copy artifact to repo
  if (opts.projectId && opts.projectId !== 'default') {
    steps.push({
      name: 'save to workspace',
      tool: 'workspace:write',
      inputs: {
        projectId: opts.projectId,
        fromStep: codegenStepName,
        artifactName: filename,
        targetPath,
        commit: true,
        commitMessage: `docs: ${topic}\n\nGenerated by NOFX`
      }
    });
  }
  if (opts.summarizeQuery && (opts.summarizeTarget || /summarize/i.test(prompt))) {
    const sumPath = String(opts.summarizeTarget || 'docs/summary.md');
    const sumName = sumPath.split('/').pop() || 'summary.md';
    steps.push({ name: 'summarize', tool: 'codegen', inputs: { topic: `Summarize: ${opts.summarizeQuery}`, bullets: ['Key points','Action items','References'], filename: sumName } });
    if (opts.openPr) {
      steps.push({ name: 'open pr (summary)', tool: 'git_pr', inputs: { branch: `feat/summary-${Date.now().toString().slice(-4)}`, base: 'main', title: `docs: summary of ${opts.summarizeQuery}`, commits: [ { path: sumPath, fromStep: 'summarize', artifactName: sumName } ] } });
    }
  }
  const prAskedInPrompt = /\bopen a pr\b/i.test(prompt);
  const prBySetting = opts.openPr === true;
  const shouldPR = prBySetting || prAskedInPrompt;
  if (shouldPR) {
    const branchBase = topic.toLowerCase().replace(/[^a-z0-9]+/g,'-').slice(0,24) || 'update-docs';
    const reason = prBySetting ? 'Setting' : 'Prompt';
    steps.push({ name: 'open pr', tool: 'git_pr', inputs: { branch: `feat/${branchBase}`, base: 'main', title: `docs: ${topic}`, commits: [ { path: targetPath, fromStep: 'write readme', artifactName: filename } ], reason } });
  }
  if (/manual approval|human approve|require approval/i.test(prompt)) {
    steps.unshift({ name: 'approval', tool: 'manual:deploy' });
  }
  const metadata: Record<string, unknown> = {};
  if (agents[0]) metadata.suggestedAgentId = agents[0].agentId;
  if (templates[0]) metadata.suggestedTemplateId = templates[0].templateId;

  return { goal: prompt || 'ad-hoc run', steps, metadata };
}
